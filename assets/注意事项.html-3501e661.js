import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as a,f as i}from"./app-56f07e55.js";const d={},l=i('<h3 id="什么是状态机" tabindex="-1"><a class="header-anchor" href="#什么是状态机" aria-hidden="true">#</a> 什么是状态机?</h3><ul><li><p>定义:</p><p><code>状态机</code>由<code>状态寄存器</code>和<code>组合逻辑电路</code>构成,能够完成根据<code>控制信号</code>按照预先设定状态进行<code>状态转移</code>等特定操作的控制中心.</p></li><li><p>分类:</p><ol><li>输出只和状态有关而与输入无关,称为<code>Moore状态机</code>.</li><li>输出与状态和输出均有关,称为<code>Mealy状态机</code>.</li></ol></li></ul><h3 id="bios和uefi以及firmware" tabindex="-1"><a class="header-anchor" href="#bios和uefi以及firmware" aria-hidden="true">#</a> BIOS和UEFI以及firmware</h3><ul><li><p>BIOS是一组固化到主板ROM上的程序,是众多firmware的一种.</p></li><li><p>UEFI和BIOS的区别:</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">UEFI</th><th style="text-align:center;">BIOS</th></tr></thead><tbody><tr><td style="text-align:center;">开发效率</td><td style="text-align:center;">开源,标准接口,用C语言编写</td><td style="text-align:center;">闭源,接口混乱,主要由汇编编写</td></tr><tr><td style="text-align:center;">性能</td><td style="text-align:center;">异步+时钟中断</td><td style="text-align:center;">中断机制</td></tr><tr><td style="text-align:center;">拓展和兼容性</td><td style="text-align:center;">模块化驱动设计</td><td style="text-align:center;">静态链接</td></tr><tr><td style="text-align:center;">安全</td><td style="text-align:center;">安全</td><td style="text-align:center;">不安全</td></tr><tr><td style="text-align:center;">其他</td><td style="text-align:center;">支持大于2T的驱动器</td><td style="text-align:center;">不支持大于2T的驱动器</td></tr></tbody></table></li></ul><h3 id="静态加载和动态加载的区别" tabindex="-1"><a class="header-anchor" href="#静态加载和动态加载的区别" aria-hidden="true">#</a> 静态加载和动态加载的区别</h3><h3 id="单步调试和单步跳过的区别" tabindex="-1"><a class="header-anchor" href="#单步调试和单步跳过的区别" aria-hidden="true">#</a> 单步调试和单步跳过的区别</h3><ul><li>单步调试: 当调用函数时,会进入函数内部,依次执行每条语句.</li><li>单步跳过: 当调用函数时,不会进入内部,而是直接返回结果.</li></ul><h3 id="附加到进程" tabindex="-1"><a class="header-anchor" href="#附加到进程" aria-hidden="true">#</a> 附加到进程</h3><p>在工程比较庞大时,通过源代码调试会非常消耗时间,使用附加到进程的方法可以缩短调试时间和调试范围.</p><h3 id="pragma-once和ifndef的区别" tabindex="-1"><a class="header-anchor" href="#pragma-once和ifndef的区别" aria-hidden="true">#</a> pragma once和ifndef的区别</h3><ul><li>ifndef支持更老的编译器,而pragma one则较新</li></ul><h3 id="头文件注意事项" tabindex="-1"><a class="header-anchor" href="#头文件注意事项" aria-hidden="true">#</a> 头文件注意事项</h3><ul><li>当一个文件引入了多个头文件，若有两个头文件中有相同名称的变量或类时，会在编译期报重定位错误。</li><li>inline函数的定义应该放在头文件中，与宏定义类似，inline需要在调用处被展开，所以编译器必须随处可见内敛函数的定义。</li><li>预编译头：include了很多头文件的头文件，叫做预编译头。</li></ul><h3 id="为什么include不建议放在头文件中" tabindex="-1"><a class="header-anchor" href="#为什么include不建议放在头文件中" aria-hidden="true">#</a> 为什么include不建议放在头文件中</h3><h3 id="c-命名方法" tabindex="-1"><a class="header-anchor" href="#c-命名方法" aria-hidden="true">#</a> C++命名方法</h3><ol><li>大驼峰命名法：每个单词首字母大写，StudioName</li><li>小驼峰命名法：第一个单词首字母小写，其余单词大写，studioName</li><li>下划线命名法：字母全小写，使用下划线连接，studio_name</li><li>匈牙利命名法：变量名=属性+类型+对象描述 <ul><li>属性：<code>g_</code>全局变量,<code>c_</code>常量,<code>m_</code>类成员变量,<code>s_</code>静态变量</li><li>类型：数组a,指针p，函数fm，空v，长整型l，布尔b，字符串str，字符c，整型n，计数cnt，无符号u等</li><li>描述：首字母大写</li></ul></li></ol><h3 id="typedef和typename关键字" tabindex="-1"><a class="header-anchor" href="#typedef和typename关键字" aria-hidden="true">#</a> typedef和typename关键字</h3>',17),r=[l];function n(c,h){return t(),a("div",null,r)}const f=e(d,[["render",n],["__file","注意事项.html.vue"]]);export{f as default};
