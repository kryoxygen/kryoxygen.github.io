import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as e}from"./app-56f07e55.js";const t="/assets/Snipaste_2023-06-02_16-33-20-8170537c.png",o="/assets/image-20230603144709690-99092779.png",p="/assets/image-20230620121120941-403a8a08.png",i="/assets/image-20230605111730251-835b1221.png",c="/assets/image-20230605144713198-281593b5.png",l="/assets/image-20230606141441720-61f64903.png",d="/assets/image-20230606141603004-103eb6cb.png",r={},u=e('<figure><img src="'+t+`" alt="内核结构图" tabindex="0" loading="lazy"><figcaption>内核结构图</figcaption></figure><h1 id="linux-进程控制" tabindex="-1"><a class="header-anchor" href="#linux-进程控制" aria-hidden="true">#</a> linux 进程控制</h1><blockquote><p>对于 Linux0.11 内核而言，只支持 64 个进程，且 Linux 的内核堆栈和恶用户堆栈是分开的。用户堆栈用于存放进程在用户态下调用函数、局部变量等参数。</p></blockquote><h2 id="任务数据结构" tabindex="-1"><a class="header-anchor" href="#任务数据结构" aria-hidden="true">#</a> 任务数据结构</h2><p>内核程序徐通过进程表对进程进行管理，每个进程表项是一个 task_struct 任务结构(即 PCB)指针。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> state<span class="token punctuation">;</span>                     <span class="token comment">// 任务的运行状态，-1不可运行，0可运行，&gt;0中止</span>
    <span class="token keyword">long</span> counter<span class="token punctuation">;</span>                   <span class="token comment">// 任务运行时间计数（时间片），递减</span>
    <span class="token keyword">long</span> priority<span class="token punctuation">;</span>                  <span class="token comment">// 运行优先数</span>
    <span class="token keyword">long</span> signal<span class="token punctuation">;</span>                    <span class="token comment">// 信号</span>
    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sigaction<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 信号属性结构</span>
    <span class="token keyword">long</span> blocked<span class="token punctuation">;</span>                   <span class="token comment">// 屏蔽码</span>
    <span class="token keyword">int</span> exit_code<span class="token punctuation">;</span>                  <span class="token comment">// 执行停止的退出码</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">;</span>       <span class="token comment">// 代码段地址</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> end_code<span class="token punctuation">;</span>         <span class="token comment">// 代码段长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> end_data<span class="token punctuation">;</span>         <span class="token comment">// 代码长度+数据长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> brk<span class="token punctuation">;</span>              <span class="token comment">// 总长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_stack<span class="token punctuation">;</span>      <span class="token comment">// 堆栈段地址</span>
    <span class="token keyword">long</span> pid<span class="token punctuation">;</span>                   <span class="token comment">// 进程号</span>
    <span class="token keyword">long</span> father<span class="token punctuation">;</span>                    <span class="token comment">// 父进程号</span>
    <span class="token keyword">long</span> pgrp<span class="token punctuation">;</span>                      <span class="token comment">// 父进程组号</span>
    <span class="token keyword">long</span> session<span class="token punctuation">;</span>                   <span class="token comment">// 会话号</span>
    <span class="token keyword">long</span> leader<span class="token punctuation">;</span>                    <span class="token comment">// 会话首领</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> uid<span class="token punctuation">;</span>             <span class="token comment">// 用户id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> euid<span class="token punctuation">;</span>            <span class="token comment">// 有效用户id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> suid<span class="token punctuation">;</span>            <span class="token comment">// 保存的用户id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> gid<span class="token punctuation">;</span>             <span class="token comment">// 组id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> egid<span class="token punctuation">;</span>            <span class="token comment">// 有效组id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> sgid<span class="token punctuation">;</span>            <span class="token comment">// 保存的组id</span>
    <span class="token keyword">long</span> alarm<span class="token punctuation">;</span>                     <span class="token comment">// 报警定时值</span>
    <span class="token keyword">long</span> utime<span class="token punctuation">;</span>                     <span class="token comment">// 用户态运行时间</span>
    <span class="token keyword">long</span> stime<span class="token punctuation">;</span>                     <span class="token comment">// 系统态运行时间</span>
    <span class="token keyword">long</span> cutime<span class="token punctuation">;</span>                    <span class="token comment">// 子进程用户态运行时间</span>
    <span class="token keyword">long</span> cstime<span class="token punctuation">;</span>                    <span class="token comment">// 子进程系统态运行时间</span>
    <span class="token keyword">long</span> start_time<span class="token punctuation">;</span>                <span class="token comment">// 进程开始时刻</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> used_math<span class="token punctuation">;</span>       <span class="token comment">// 标志是否使用了</span>
    <span class="token keyword">int</span> tty<span class="token punctuation">;</span>                        <span class="token comment">// 进程使用tty的设备号</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> umask<span class="token punctuation">;</span>           <span class="token comment">// 文件创建属性屏蔽位</span>
    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>pwd<span class="token punctuation">;</span>            <span class="token comment">// 当前工作目录i节点结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>           <span class="token comment">// 根目录i节点结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>executable<span class="token punctuation">;</span>     <span class="token comment">// 执行文件i节点结构</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> close_on_exec<span class="token punctuation">;</span>    <span class="token comment">// 执行时关闭文件句柄位图标志</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">[</span>NR_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 文件结构指针表</span>
    <span class="token keyword">struct</span> <span class="token class-name">desc_struct</span> ldt<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 任务局部指针表</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> tss<span class="token punctuation">;</span>          <span class="token comment">// 进程的任务状态段信息结构</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>进程上下文: 一个进程执行时,CPU 的所有寄存器中的值、进程的状态以及堆栈中的内容被称为上下文.当发生进程调度时,将当前进程上下文保存在该进程的任务数据结构中.</li></ul><h2 id="进程运行状态" tabindex="-1"><a class="header-anchor" href="#进程运行状态" aria-hidden="true">#</a> 进程运行状态</h2><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>运行态/就绪态(0):等待运行和正在运行的进程均以 0 标识.</li><li>可中断睡眠态(1):进程处于等待系统中断或等待资源的状态,当条件满足时,会进入就绪态.</li><li>不可中断睡眠状态(2):该类型进程不能被中断类型唤醒,只能手动调用 wake_up()函数来唤醒.</li><li>僵死状态(3):已经停止运行,但其父进程还未询问状态的进程.</li><li>暂停状态(4):由外部干扰,接收到 SIGTOP、SIGTSTP、SIGTTIN、SIGTTOU 等信号时会进入暂停态,可以用 SIGCONT 信号让其进入就绪态.</li></ul><blockquote><p>只有在用户态才会接受中断,而在内核态进程间的切换中,只用当前进程结束或调用 sleep_on()等函数主动退出运行态是,才会发生进程切换.</p></blockquote><h2 id="进程初始化" tabindex="-1"><a class="header-anchor" href="#进程初始化" aria-hidden="true">#</a> 进程初始化</h2><p>过程：当 32 位 CPU 上电后，会先进入实模式，从地址 0xFFFF0(ROM-BIOS)开始执行 BIOS 检测程序并在物理地址 0 处初始化中断向量,此后将启动设备的第一个扇区读入内存 0x7C00 处,并跳转到该地址,之后进入保护模式执行系统初始化程序(进程 0).完成初始化后使用 move_to_user_mode 宏将当前进程由内核态(特权级 0)转为用户态(特权级 3).</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="进程切换" tabindex="-1"><a class="header-anchor" href="#进程切换" aria-hidden="true">#</a> 进程切换</h2><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>进程切换的任务由 switch_to()宏定义的汇编代码完成:</p><ul><li>首先检查切换到的进程 ID 是否为当前进程 ID</li><li>将内核全局变量 current 置为新任务的指针</li><li>将当前所有寄存器状态保存至原 TSS(任务状态段)中,再将新 TSS 中的数据写入寄存器中</li><li>开始执行新进程</li></ul><h2 id="终止进程" tabindex="-1"><a class="header-anchor" href="#终止进程" aria-hidden="true">#</a> 终止进程</h2><ul><li>当一个程序需要终止时会调用 exit()系统调用,执行内核函数 do_exit()</li><li>先释放进程代码段和数据段在内存中的页面,关闭进程所有打开的文件 <ul><li>若该进程有子进程,则将 init 进程(0 号进程)作为其所有子进程的父进程</li><li>当子进程被终止并处于僵死状态,需要等到父进程使用 wait()或者 waitpid()来询问子进程状态才会死亡,父进程会把子进程的运行时间加到自己的进程中,释放已终止子进程所占的内存页面</li></ul></li></ul><h1 id="linux-内核对内存的使用" tabindex="-1"><a class="header-anchor" href="#linux-内核对内存的使用" aria-hidden="true">#</a> linux 内核对内存的使用</h1><h2 id="全局描述符表gdt和局部描述符表ldt" tabindex="-1"><a class="header-anchor" href="#全局描述符表gdt和局部描述符表ldt" aria-hidden="true">#</a> 全局描述符表GDT和局部描述符表LDT</h2><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="linux中的堆栈" tabindex="-1"><a class="header-anchor" href="#linux中的堆栈" aria-hidden="true">#</a> linux中的堆栈</h1><blockquote><p>Linux0.11共有使用了四种堆栈: 系统初始化临时使用的堆栈,内核堆栈(任务0的堆栈),内核态堆栈,用户态堆栈</p></blockquote><h2 id="任务的堆栈" tabindex="-1"><a class="header-anchor" href="#任务的堆栈" aria-hidden="true">#</a> 任务的堆栈</h2><h3 id="用户态堆栈" tabindex="-1"><a class="header-anchor" href="#用户态堆栈" aria-hidden="true">#</a> 用户态堆栈</h3><h3 id="内核态堆栈" tabindex="-1"><a class="header-anchor" href="#内核态堆栈" aria-hidden="true">#</a> 内核态堆栈</h3><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个进程的内核态堆栈位于其任务数据结构所在页面的末端,当一个任务进入内核态执行时,其内核堆栈总是空的.</p><h3 id="任务内核态堆栈和用户态堆栈的切换" tabindex="-1"><a class="header-anchor" href="#任务内核态堆栈和用户态堆栈的切换" aria-hidden="true">#</a> 任务内核态堆栈和用户态堆栈的切换</h3><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当一个用户态进程执行int程序后进入内核态,其内核态堆栈会记录用户态堆栈的栈顶和栈基地址.</p>',33),k=[u];function m(g,h){return s(),a("div",null,k)}const y=n(r,[["render",m],["__file","Linux内核体系结构.html.vue"]]);export{y as default};
